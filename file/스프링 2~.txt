강의에서 알려주는 에러 처리 내용은 뭐랄까
페이지 자체를 변경해버리는데,
우리 회사 같은 구조면 api를 다른 서버에 호출한 다음
resultCode 같은 형식으로 받아서 사용하니까 페이지를 이동시키는 게 좋지 않을까?
그러면 결국 같은 구조가 되는 게 아닌가 싶긴 하다.

겟방식을 잘 쓰진 않겠지만, 쓸 때 사용될 수 있는
'pathVariable'이 있다.
@RequestParam? 처럼 쓸 수 있는 것 같다.

드디어 ResponseEntity를 쓰는 모습이다.

근데 여기선 Map<String,Object>를 사용한다
그럼 결국 잘 생각해보면 우리 회사에서 쓰는 방식이랑 똑같은 듯?

Jackson라이브러리는 Map을 JSON구조로 변환할 수 있다고 한다.

ResponseEntity를 사용하면서 응답하기 때문에 컨버터가 동작하면서 클라이언트에 JSON이 반환된다.

API 예외 처리 - HandlerExceptionResolver 시작

예외가 발생해서 서블릿을 넘어 WAS까지 전달이 되면 HTTP상태코드가 500으로 처리된다.

인터럽트에 있는 postHandle이 있었다.
그리고 afterCompletion이라는 게 있었다.

근데 postHandle은 예외가 발생하면 처리가 되지 않는다고 하였었다.
그래서 이렇게 HandlerExceptionResolver로 오류 핸들링을 하더라도 따로 postHandle이 호출되지 않는다는 사실은 변하진 않는다.

* service 로직을 interface와 impl로 나누는 이유
장점 : 
- 유연한 구조 설계를 할 수 있다 - 구현체를 자유롭게 바꿀 수 있다. 한가지 인터페이스를 활용하여 여러가지 구현체를 쉽게 만들 수 있다는 것이다.
- 단위 테스트 용이 : 테스트 시 Mock 구현체나 Fake 구현체로 교체하기 쉽기 때문에 테스트 환경을 깔끔하게 유지할 수 있다.
- 관심사의 분리 : 인터페이스는 역할만 정의하고, 실제 동작은 구현체가 맡음으로써 책임을 나눌 수 있다.(무엇을 할 것인가 vs 어떻게 할 것인가를 명확하게 나눌 수 있다.)
- SOLID 원칙 중 DIP 충족 : 고수준 모듈(UserController)는 저수준 모듈(UserServiceImpl)에 의존하지 않고, 추상화(UserService 인터페이스)에 의존한다.

단점 :
- 코드가 불필요하게 늘어난다 : 코드량이 많아지고 관리 포인트가 늘어난다.
- 과한 추상화 : 변경 가능성이 거의 없거나 단일 구현만 존재하는 경우에는 굳이 interface를 만들 필요가 없다. 굳이 불 필요한 계층이 되기도 한다.
- 단순한 CRUD 서비스인데 interface/impl을 나누면 오히려 복잡도가 증가할 수도 있다.

빈 ModelAndView를 반환하면 뷰를 렌더링 하지 않고, 정상 흐름으로 서블릿이 리턴된다.

ModelAndView 지정 : VIew및 Model 등의 정보를 지정해서 반환하면 뷰를 렌더링 한다.

null : null을 반환하면, 다음 ExceptionResolver를 찾아서 실행한다. 만약 처리할 수 있는 ExceptionResolver가 없으면 예외 처리가 안되고, 기존에 발생한 예외를 서블릿 밖으로 던진다.

ExceptionResolver 활용 :
예외 상태 코드 반환 : 

여기서 궁금한 부분 : 지금 우리가 쓰는 회사 프로젝트에서는 Exception을 따로 send 해주는 메서드가 있는 걸까?
아니면 그냥 was 밖으로 나가졌기 때문에 그렇게 되는 걸까?

@ExceptionHandler를 쓰면 된다고 하는 듯.
이게 api방식을 하는 데에 아주 좋은 거 같음

기본으로 제공하는 ExceptionResolver 중에서도 우선순위가 가장 높다.

class가 따로 상속을 받을 필요는 없고,
그냥 ExceptionHandler를 붙여서 쓰는 거 같음
자세한 사용법은 차후에 더 찾아보도록 하자

상위 부모 예외를 괄호 안에 지정해주면 그 클래스와 자식 클래스까지 모두 처리할 수 있다.

컨버터를 생성하는 방법은
class를 만들면서 implements Converter<Type A, Type B>을 정해주면 된다.

그리고 @Override를 하면서
Type A를 B로 바꿔주는 로직을 써주면 된다.

스프링은 용도에 따라 다양한 방식의 타입 컨버터를 제공한다.

Converter,
COnverterFactory,
GenericConverter,
ConditionalGenericConverter

스프링은 컨버전 서비스를 제공한다.
ConversionService(인터페이스) : 개별 컨버터를 모아두고 그것들을 묶어서 편리하게 사용할 수 있는 기능을 제공한다.
컨버전 서비스 인터페이스는, 단순히 컨버팅이 가능한가? 확인하는 기능과, 컨버팅 기능을 제공한다.

컨버전 서비스객체를 new DefauiltConversionService 로 해서 만들고
addConverter로 하여금 미리 추가를 해준다.

그 다음에는 생성된 객체의 .convert(A,B)를 해주면 된다.
이 때 A 혹은 B에 객체 형태로 전달이 되어야 한다면
new 객체 형태로 생성하면서 생성자로 넣어줘야 한다.

DefaultConversionService는 ConversionService를 구현했으면서 추가로 컨버터를 등록하는 기능도 제공해준다.